---
title: "포켓몬스터 도감 사이트"
description: "React와 TanStack Query를 활용한 포켓몬 도감 웹 애플리케이션. PokeAPI 연동, 무한 스크롤, 카드 플립 애니메이션, 한글 지원 등 다양한 기능을 구현했습니다."
date: "2025-01-17"
tags: ["개인프로젝트", "React", "반응형", "디자인"]
featured: true
readTime: "12 min read"
author: "arghya"
thumbnail: "/thumbnails/pokemon-dex.jpg"
---

포켓몬스터 도감 웹 애플리케이션을 제작하여 React 생태계의 최신 기술 스택을 활용한 실전 프로젝트를 구현했습니다. 사용자 경험을 최우선으로 하는 인터랙티브한 UI와 효율적인 데이터 관리를 중점적으로 개발했습니다.

<ImageViewer
  src="https://images.unsplash.com/photo-1613771404721-1f92d799e49f?w=900&auto=format&fit=crop&q=60"
  alt="Pokemon Pokedex"
  caption="포켓몬 도감 프로젝트 - 카드 기반 인터페이스"
/>

<div style={{textAlign: 'center', margin: '32px 0'}}>
  <a href="https://sp-timer.web.app/pokemon" target="_blank" rel="noopener noreferrer" style={{display: 'inline-block', padding: '12px 32px', background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', color: 'white', textDecoration: 'none', borderRadius: '8px', fontWeight: 600, fontSize: '16px', boxShadow: '0 4px 12px rgba(59, 130, 246, 0.3)'}}>
    🔗 사이트 보러가기
  </a>
</div>

## 프로젝트 개요

이 프로젝트는 전 세대 포켓몬 정보를 제공하는 웹 기반 도감 애플리케이션입니다. PokeAPI를 활용하여 실시간 데이터를 가져오고, 사용자 친화적인 인터페이스로 정보를 제공합니다.

### 주요 기능

- **무한 스크롤**: 스크롤 시 자동으로 다음 포켓몬 데이터 로딩
- **실시간 검색**: 포켓몬 이름 또는 번호로 즉시 검색
- **카드 플립 애니메이션**: 카드를 클릭하여 상세 정보 확인
- **한글/영문 이름 지원**: PokeAPI Species 엔드포인트 활용
- **타입별 색상 구분**: 18가지 포켓몬 타입별 고유 색상 적용
- **반응형 디자인**: 모바일부터 데스크톱까지 완벽 대응

### 기술 스택

**Frontend**
- React 18 + TypeScript
- TanStack Query (React Query v5)
- Emotion (styled-components)
- Vite

**API & Deployment**
- PokeAPI
- Firebase Hosting

## 핵심 구현 사항

### 1. TanStack Query를 활용한 데이터 관리

효율적인 서버 상태 관리를 위해 TanStack Query를 도입했습니다. 캐싱, 자동 리페칭, 무한 스크롤 등의 기능을 손쉽게 구현할 수 있었습니다.

```tsx
// 무한 스크롤 구현
export const usePokemonList = () => {
  return useInfiniteQuery({
    queryKey: ['pokemon', 'list'],
    queryFn: ({ pageParam = 0 }) => pokemonApi.getPokemonList(20, pageParam),
    getNextPageParam: (lastPage, pages) => {
      if (!lastPage.next) return undefined;
      return pages.length * 20;
    },
    initialPageParam: 0,
  });
};

// 개별 포켓몬 상세 정보
export const usePokemon = (name: string) => {
  return useQuery({
    queryKey: ['pokemon', name],
    queryFn: () => pokemonApi.getPokemonByName(name),
    enabled: !!name,
  });
};

// 한글 이름 가져오기
export const usePokemonSpecies = (id: number | undefined) => {
  return useQuery({
    queryKey: ['pokemon', 'species', id],
    queryFn: () => pokemonApi.getPokemonSpecies(id!),
    enabled: !!id,
  });
};
```

### 2. 3D 카드 플립 애니메이션

CSS 3D transform을 활용하여 카드 앞뒤면을 전환하는 인터랙티브 UI를 구현했습니다.

```tsx
const CardInner = styled.div<{ isFlipped: boolean }>`
  position: relative;
  width: 100%;
  height: 400px;
  transition: transform 0.6s;
  transform-style: preserve-3d;
  transform: ${props => props.isFlipped ? 'rotateY(180deg)' : 'rotateY(0)'};
`;

const CardFace = styled.div<{ bgColor: string }>`
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  border-radius: 16px;
  padding: 24px;
  background: ${props => props.bgColor};
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
`;

const CardBack = styled(CardFace)`
  transform: rotateY(180deg);
  overflow-y: auto;
`;
```

### 3. 한글 이름 지원

PokeAPI의 Pokemon Species 엔드포인트를 활용하여 다국어 이름 데이터를 가져와 한글 이름을 표시했습니다.

```tsx
const getKoreanName = () => {
  if (!speciesData?.names) return data?.name;
  const koreanName = speciesData.names.find(
    (name: any) => name.language.name === 'ko'
  );
  return koreanName?.name || data?.name;
};

// 능력치 라벨도 한글로 변환
const getStatNameKorean = (statName: string): string => {
  const statNameMap: { [key: string]: string } = {
    'hp': 'HP',
    'attack': '공격',
    'defense': '방어',
    'special-attack': '특수공격',
    'special-defense': '특수방어',
    'speed': '스피드'
  };
  return statNameMap[statName] || statName;
};
```

### 4. 타입별 동적 색상 시스템

포켓몬의 주 타입에 따라 카드 배경색이 동적으로 변경되어 시각적 구분이 용이합니다.

```tsx
const typeColors: { [key: string]: string } = {
  normal: '#A8A878',
  fire: '#F08030',
  water: '#6890F0',
  electric: '#F8D030',
  grass: '#78C850',
  ice: '#98D8D8',
  fighting: '#C03028',
  poison: '#A040A0',
  ground: '#E0C068',
  flying: '#A890F0',
  psychic: '#F85888',
  bug: '#A8B820',
  rock: '#B8A038',
  ghost: '#705898',
  dragon: '#7038F8',
  dark: '#705848',
  steel: '#B8B8D0',
  fairy: '#EE99AC',
};

const mainType = data.types[0].type.name;
const backgroundColor = typeColors[mainType] || '#A8A878';
```

## 검색 기능 구현

실시간 검색을 통해 포켓몬 이름이나 번호로 즉시 찾을 수 있습니다.

```tsx
export const useSearchPokemon = (query: string) => {
  return useQuery({
    queryKey: ['pokemon', 'search', query],
    queryFn: () => pokemonApi.searchPokemon(query),
    enabled: query.length > 0,
    retry: false,
  });
};

// SearchBar 컴포넌트
const SearchBar: FC<SearchBarProps> = ({ onSearch }) => {
  const [query, setQuery] = useState('');

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (query.trim()) {
      onSearch(query.trim().toLowerCase());
    }
  };

  return (
    <Form onSubmit={handleSubmit}>
      <SearchInput
        type="text"
        placeholder="영어로 입력하세요"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <SearchButton type="submit">🔍 검색</SearchButton>
    </Form>
  );
};
```

## 성능 최적화

### Lazy Loading & 이미지 최적화

```tsx
<PokemonImage
  src={data.sprites.other['official-artwork'].front_default}
  alt={data.name}
  loading="lazy"
/>
```

### React Query 캐싱 전략

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5분
      gcTime: 10 * 60 * 1000,   // 10분
    },
  },
});
```

## 반응형 디자인

Grid 레이아웃과 미디어 쿼리를 활용하여 다양한 화면 크기에 대응합니다.

```tsx
const PokemonGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 24px;
  padding: 24px;

  @media (max-width: 640px) {
    grid-template-columns: 1fr;
    padding: 16px;
  }

  @media (min-width: 641px) and (max-width: 1024px) {
    grid-template-columns: repeat(2, 1fr);
  }

  @media (min-width: 1025px) {
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  }
`;
```

## API 통합

PokeAPI의 여러 엔드포인트를 활용하여 풍부한 데이터를 제공합니다.

```tsx
const BASE_URL = 'https://pokeapi.co/api/v2';

export const pokemonApi = {
  // 포켓몬 목록
  getPokemonList: async (limit: number = 20, offset: number = 0) => {
    const response = await fetch(
      `${BASE_URL}/pokemon?limit=${limit}&offset=${offset}`
    );
    if (!response.ok) throw new Error('Failed to fetch Pokemon list');
    return response.json();
  },

  // 개별 포켓몬 상세 정보
  getPokemonByName: async (name: string) => {
    const response = await fetch(`${BASE_URL}/pokemon/${name}`);
    if (!response.ok) throw new Error(`Failed to fetch Pokemon: ${name}`);
    return response.json();
  },

  // 포켓몬 종 정보 (한글 이름)
  getPokemonSpecies: async (id: number) => {
    const response = await fetch(`${BASE_URL}/pokemon-species/${id}`);
    if (!response.ok) throw new Error(`Failed to fetch Pokemon species: ${id}`);
    return response.json();
  }
};
```

## 배포

Firebase Hosting을 통해 프로덕션 배포를 진행했습니다.

```bash
# 프로젝트 빌드
npm run build

# Firebase 배포
firebase deploy --only hosting
```

**라이브 데모**: [https://sp-timer.web.app](https://sp-timer.web.app)

## 프로젝트를 통해 배운 점

### 1. TanStack Query의 강력함
서버 상태 관리의 복잡성을 크게 줄일 수 있었습니다. 캐싱, 리페칭, 무한 스크롤 등이 선언적으로 구현 가능했습니다.

### 2. TypeScript의 중요성
API 응답 타입을 정의함으로써 개발 중 오류를 사전에 방지하고 자동완성의 이점을 누릴 수 있었습니다.

### 3. CSS 3D Transform 활용
복잡한 라이브러리 없이도 CSS만으로 인상적인 3D 애니메이션을 구현할 수 있었습니다.

### 4. API 설계 이해
RESTful API의 구조와 관계형 엔드포인트를 이해하고 효율적으로 활용하는 방법을 배웠습니다.

## 향후 개선 계획

- 포켓몬 비교 기능 추가
- 타입별 필터링 기능
- 즐겨찾기 기능 (LocalStorage)
- 진화 체인 시각화
- PWA 적용으로 오프라인 지원
- 다크 모드 지원

## 마치며

이 프로젝트를 통해 React 생태계의 최신 기술 스택을 실전에 적용하고, 사용자 경험을 고려한 인터페이스 설계 능력을 향상시킬 수 있었습니다. 특히 TanStack Query를 활용한 효율적인 데이터 관리와 Emotion을 통한 컴포넌트 스타일링 경험이 매우 유익했습니다.
